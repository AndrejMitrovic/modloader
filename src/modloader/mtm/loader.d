/*
 *             Copyright Andrej Mitrovic 2014.
 *  Distributed under the Boost Software License, Version 1.0.
 *     (See accompanying file LICENSE_1_0.txt or copy at
 *           http://www.boost.org/LICENSE_1_0.txt)
 */
module modloader.mtm.loader;

import std.algorithm  : filter;
import std.conv       : text;
import std.exception  : enforce;

import modloader.util : modDir, streamFile, ZCharArray;

import modloader.mtm.internal : ModuleHeader, toModule;
import modloader.mtm.types    : Module, Sample, Track, TrackRow, Pattern;
import modloader.mtm.util     : decodeComment, toSampleSize;

/**
    Read a Multi Track Module file.

    The MTM format is generated by the Multi Track Module tracker by the demo group
    Renaissance. The tracker features up to 32 channel digital music. Instead of
    saving whole patterns, the tracker only saves the different tracks and the data
    which tracks should be played together at which time, thus saving some pattern
    space.

    MTM Reference:
    ftp://ftp.modland.com/pub/documents/format_documentation/MultiTracker%20%28.mtm%29%20%233.txt
*/
Module readMTM(string path)
{
    import std.array : uninitializedArray;

    auto file = path.streamFile;
    enforce(file.size > 0);

    auto modHeader = file.read!ModuleHeader;

    with (modHeader)
    {
        enforce(id == "MTM");
        enforce(version_ == 16);  // note: unspecified
        enforce(lastPattern > 0);
        enforce(lastOrder > 0);
        enforce(numTracks > 0);
        enforce(numSamples > 0);
        enforce(numChannels > 0 && numChannels <= 32, numChannels.text);
    }

    auto mod = modHeader.toModule();

    enum HeaderSize = 66;
    enforce(file.pos == HeaderSize);

    enum SampleByteSize = 37;
    enum PatternOrderSize = 128;
    enum TrackByteSize = 64 * 3;
    enum PatternByteSize = 32 * short.sizeof;

    const totalBytes = HeaderSize +
                       SampleByteSize * modHeader.numSamples +
                       PatternOrderSize +
                       TrackByteSize * modHeader.numTracks +
                       PatternByteSize * modHeader.numOfPatterns +
                       modHeader.commentSize;

    enforce(totalBytes < file.size);

    mod.samples = uninitializedArray!(Sample[])(modHeader.numSamples);

    foreach (ref sample; mod.samples)
    {
        sample = file.read!Sample;
    }

    enforce(file.pos == 0x42 + modHeader.numSamples * SampleByteSize);

    mod.patternOrders = file.read!(ubyte[128])[0 .. modHeader.numOfOrders].dup;

    enforce(file.pos == 0xC2 + modHeader.numSamples * SampleByteSize);

    mod.tracks = uninitializedArray!(Track[])(modHeader.numTracks);

    foreach (ref track; mod.tracks)
    {
        foreach (ref row; track.rows)
        {
            row = file.read!TrackRow;
        }
    }

    enforce(file.pos == 0xC2 +
            modHeader.numSamples * SampleByteSize +
            modHeader.numTracks * TrackByteSize);

    mod.patterns = uninitializedArray!(Pattern[])(modHeader.numOfPatterns);
    foreach (ref pattern; mod.patterns)
    {
        pattern = file.read!Pattern;
    }

    enforce(file.pos == 0xC2 +
            modHeader.numSamples * SampleByteSize +
            modHeader.numTracks * TrackByteSize +
            modHeader.numOfPatterns * PatternByteSize);

    mod.comment = file.read!(char[])(modHeader.commentSize).decodeComment().idup;

    enforce(file.pos == 0xC2 +
            modHeader.numSamples * SampleByteSize +
            modHeader.numTracks * TrackByteSize +
            modHeader.numOfPatterns * PatternByteSize +
            modHeader.commentSize);

    foreach (ref sample; mod.samples.filter!(a => a.length))
    {
        size_t byteCount = sample.length * sample.sampleType.toSampleSize;
        enforce(byteCount, sample.text);

        sample.sampleData = uninitializedArray!(ubyte[])(byteCount);
        file.readTo(sample.sampleData);
    }

    enforce(file.end);

    return mod;
}

///
version (TestModloader)
unittest
{
    import std.path : buildPath;
    import std.stdio : writeln;

    foreach (modFile; testModFiles)
        modDir.buildPath(modFile).readMTM.writeln;
}

version (unittest)
private immutable testModFiles =
[
    "hacksaw.mtm",
    "modern_society.mtm",
];
