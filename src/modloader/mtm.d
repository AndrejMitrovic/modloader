/*
 *             Copyright Andrej Mitrovic 2014.
 *  Distributed under the Boost Software License, Version 1.0.
 *     (See accompanying file LICENSE_1_0.txt or copy at
 *           http://www.boost.org/LICENSE_1_0.txt)
 */
module modloader.mtm;

import std.algorithm  : filter;
import std.conv       : text, to;
import std.exception  : enforce;
import std.stdio      : writeln, writefln;
import std.traits     : isSomeChar;

import modloader.util : modDir, streamFile, SkipLoad, ZCharArray;

///
enum ChannelType : ubyte { invalid = ubyte.max, bit8 = 0x00, bit16 = 0x01, }

///
struct Module
{
    ///
    @ZCharArray(3)
    string id;

    ///
    byte version_;

    ///
    @ZCharArray(20)
    string songName;

    ///
    ushort numTracks;

    ///
    ubyte lastPattern;

    ///
    ubyte lastOrder;

    ///
    @property ubyte numOfOrders()
    {
        import std.conv : to;
        return to!ubyte(lastOrder + 1);
    }

    ///
    short commentSize;

    ///
    ubyte numSamples;

    ///
    @property ubyte numOfPatterns()
    {
        import std.conv : to;
        return to!ubyte(lastPattern + 1);
    }

    ///
    ChannelType channelType;

    ///
    ubyte beatsPerTrack;

    ///
    ubyte numChannels;

    ///
    ubyte[32] panPositions;

    ///
    @SkipLoad Sample[] samples;

    ///
    @SkipLoad Track[] tracks;

    ///
    @SkipLoad Pattern[] patterns;

    ///
    @SkipLoad ubyte[] patternOrders;

    ///
    @SkipLoad string comment;

    ///
    string toString()
    {
        import std.string : format;

        return format(
            "%-10s: %s\n"
            "%-10s: %s\n"
            "%-10s: %s\n"
            "%-10s: %s\n",

            "song_name", songName,
            "samples",   samples.length,
            "tracks",    tracks.length,
            "patterns",  patterns.length,
        );
    }
}

///
enum SampleType : ubyte { invalid = ubyte.max, bit8 = 0x00, bit16 = 0x01, }

///
struct Sample
{
    ///
    @ZCharArray(22)
    string sampleName;

    ///
    uint length;

    ///
    uint loopStart;

    ///
    uint loopEnd;

    ///
    byte fineTune;

    ///
    ubyte volume;

    ///
    SampleType sampleType;

    ///
    @SkipLoad ubyte[] sampleData;
}

///
struct TrackRow
{
    import std.bitmanip : bitfields;

    ///
    mixin(bitfields!(
        uint, "pitchValue", 6,
        uint, "instrumentNumber", 6,
        uint, "effectNumber", 4));

    ///
    ubyte effectArgument;

    ///
    string toString()
    {
        import std.string : format;

        return format("%s: %3s %s: %3s %s: %3s %s: %3s",
            "pitchValue",       pitchValue,
            "instrumentNumber", instrumentNumber,
            "effectNumber",     effectNumber,
            "effectArgument",   effectArgument);
    }
}

///
enum RowCount = 64;

///
struct Track
{
    ///
    TrackRow[RowCount] rows;
}

///
enum VoiceCount = 32;

///
struct Pattern
{
    ///
    short[VoiceCount] voices;

    ///
    string toString()
    {
        import std.string : format;
        return format("%(%3s %)", voices);
    }
}

/**
    Read a Multi Track Module file.

    The MTM format is generated by the Multi Track Module tracker by the demo group
    Renaissance. The tracker features up to 32 channel digital music. Instead of
    saving whole patterns, the tracker only saves the different tracks and the data
    which tracks should be played together at which time, thus saving some pattern
    space.

    MTM Reference:
    ftp://ftp.modland.com/pub/documents/format_documentation/MultiTracker%20%28.mtm%29%20%233.txt
*/
Module readMTM(string path)
{
    import std.array : uninitializedArray;

    auto file = path.streamFile;
    enforce(file.size > 0);

    auto mod = file.read!Module;

    with (mod)
    {
        enforce(id == "MTM");
        enforce(version_ == 16);  // note: unspecified
        enforce(lastPattern > 0);
        enforce(lastOrder > 0);
        enforce(numTracks > 0);
        enforce(numSamples > 0);
        enforce(numChannels > 0 && numChannels <= 32, numChannels.text);
    }

    enum HeaderSize = 66;
    enforce(file.pos == HeaderSize);

    enum SampleByteSize = 37;
    enum PatternOrderSize = 128;
    enum TrackByteSize = 64 * 3;
    enum PatternByteSize = 32 * short.sizeof;

    const totalBytes = HeaderSize +
                       SampleByteSize * mod.numSamples +
                       PatternOrderSize +
                       TrackByteSize * mod.numTracks +
                       PatternByteSize * mod.numOfPatterns +
                       mod.commentSize;

    enforce(totalBytes < file.size);

    mod.samples = uninitializedArray!(Sample[])(mod.numSamples);

    foreach (ref sample; mod.samples)
    {
        sample = file.read!Sample;
    }

    enforce(file.pos == 0x42 + mod.numSamples * SampleByteSize);

    mod.patternOrders = file.read!(ubyte[128])[0 .. mod.numOfOrders].dup;

    enforce(file.pos == 0xC2 + mod.numSamples * SampleByteSize);

    mod.tracks = uninitializedArray!(Track[])(mod.numTracks);

    foreach (ref track; mod.tracks)
    {
        foreach (ref row; track.rows)
        {
            row = file.read!TrackRow;
        }
    }

    enforce(file.pos == 0xC2 +
            mod.numSamples * SampleByteSize +
            mod.numTracks * TrackByteSize);

    mod.patterns = uninitializedArray!(Pattern[])(mod.numOfPatterns);
    foreach (ref pattern; mod.patterns)
    {
        pattern = file.read!Pattern;
    }

    enforce(file.pos == 0xC2 +
            mod.numSamples * SampleByteSize +
            mod.numTracks * TrackByteSize +
            mod.numOfPatterns * PatternByteSize);

    mod.comment = file.read!(char[])(mod.commentSize).decodeComment().idup;

    enforce(file.pos == 0xC2 +
            mod.numSamples * SampleByteSize +
            mod.numTracks * TrackByteSize +
            mod.numOfPatterns * PatternByteSize +
            mod.commentSize);

    foreach (ref sample; mod.samples.filter!(a => a.length))
    {
        size_t byteCount = sample.length * sample.sampleType.toSampleSize;
        enforce(byteCount, sample.text);

        sample.sampleData = uninitializedArray!(ubyte[])(byteCount);
        file.readTo(sample.sampleData);
    }

    enforce(file.end);

    return mod;
}

///
unittest
{
    import std.path : buildPath;

    foreach (modFile; testModFiles)
        modDir.buildPath(modFile).readMTM.writeln;
}

version (unittest)
private immutable testModFiles =
[
    "hacksaw.mtm",
    "modern_society.mtm",
];

/// MTM comments have their own encoding.
private char[] decodeComment(char[] input)
{
    foreach (idx, ref char ch; input)
    {
        if (!ch)
            ch = (idx + 1) % 40 ? 0x20 : 0x0D;
    }

    return input;
}

/// Get the byte count for the sample type.
private size_t toSampleSize(SampleType sampleType)
{
    switch (sampleType) with (SampleType)
    {
        case bit8:
            return 1;

        case bit16:
            return 2;

        default:
            assert(0);
    }
}
